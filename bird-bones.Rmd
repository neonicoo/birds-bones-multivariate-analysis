---
title: "Bird's bones"
author: Nicolas Mendiboure 4BiM
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction au sujet :

Source du jeu de données : https://www.kaggle.com/zhangjuefei/birds-bones-and-living-habits

Il existe un très grand nombre d'espèces d'oiseaux différentes telles que les canards, les autruches, les pinguins ou les pigeons etc... 
Certains parmi eux sont capable de voler, d'autres de nager à la surface de l'eau où en profondeur, ou bien encore de courrir vite pour attraper une proie ou fuir un prédateur. 
Ainsi selon leur milieu de vie et leurs habitudes de vie, les oiseaux étudier dans ce jeu de donées ont été classés selon six groupes écologiques différents :

1. Les oiseaux nageurs (SW);
2. Les oiseaux échassiers ou limicoles (W);
3. Les oiseaux terrestres (T);
4. Les oiseaux "raptors" (R);
5. Les oiseaux grimpeurs (P);
6. Les oiseaux Chanteurs (SO).


Par ailleurs tous les oiseaux appartenant à des groupes écologiques différents présentes des caractéristiques et apparences différentes. Les oiseaux volant possèdes de grandes ailes, les échassiers ont de grandes pattes etc... 
Or il existe un attribut que nous pouvons comparer chez chaque catégorie d'oiseaux, il s'agit des os. 
Ainsi en tant que spécialiste des données et des analyses en biostatistiques, nous allons chercher à voir s'il existe une relation entre les différents groupes écologiques d'oiseaux et la forme de leurs os. Nous pourrons aussi regarder si ces différentes tailles d'os sont corrélée entre elle, par exemple savoir si il y a une relation entre la taille de l'os du fémur et celle de l'humérus. 

Pour ce faire 10 mesures ont été faites sur 420 oiseaux différents. Plus précisément, les mesures ont été prises sur des squelettes d'oiseaux provenant du Musée Naturel d'Histoire de Los Angeles, on y trouves notament 21 ordres, 153 genres et 254 éspèces d'oiseaux différentes.

Les 10 mesures sont les suivantes (en milimètre) :

1. Longueur Humérus ;
2. Diamètre Humérus ;
3. Longueur avant bras (Ulna) ;
4. Diamètre Ulna ;
5. Longueur Fémur ;
6. Diamètre Fémur ;
7. Longueur Tibiotarse ;
8. Diamètre Tibiotarse ;
9. Longeur Tarso-mététarse ;
10. Diamètre Tarso-métatarse.

Ce jeu de données est fourni par le Dr. D.Liu du Musée Naturel d'Hisoire de Pékin.

# Visualisation des données :

Il faut s'assurer de bien effacer les variables stockées dans R avant de commencer :

```{r rm var}
rm(list=ls())
```


On charge tout d'abord les libraries dont nous allons avoir besoin pour la suite de ce devoir :

```{r libraries, message=FALSE}
library(ade4)
library(adegraphics)
```

Nous chargeons maintenant nos données dans une varible *birds*, qu'il est possible de visualiser avec la commande *View(birds)*. Ensuite il faut s'assurer que nos jeu de données est complet, c'est à dire que chaque individu possède une valeur respective pour chaque variable. Pour se faire nous allons supprimer les lignes (et donc individus) qui possèdent des "Na" comme valeur grâce à la commande : *birds[complete.cases(birds),]*. En effet comme nous avons un total de 420 individus, nous pouvons nous permettre d'en enlever quelque un. On vérifie avec la commande *sum(is.na(birds))* que nous avons bien enlevé tous les "Na" du jeu. 

```{r datas loading}
birds <- read.csv("bird.csv", sep = ",", header = TRUE)
birds <- birds[complete.cases(birds),]
sum(is.na(birds)) == 0
names(birds)
```

```{r filtrer les outliers, include=FALSE}
filter_outliers <- function(df, limit){
  index <- c()
  for (row in 1:dim(df)[1]){
    for (col in 1:dim(df)[2]){
      if (df[row, col] > limit){
        if ( (row %in% index) == FALSE ){
          index <- c(index, row)
        }
      }
    }
  }
  return(index)
}
```
On peut commencer par représenter nos données sur un boxplot. On voit tout de suite qu'il y a une hétérogénéité des moyennes et des variances entre nos 10 variables, avec notamment 2 groupes distincts de mesures. Cela est cohérent avec la réalité car les longueurs d'os sont logiquement plus élevées que les diamètres des os. Afin de replacer l'ensemble de nos données sur une homogénéité des moyennes et des variances, nous allons **centrer - réduire** notre jeu de données avec la commande *scale(bones)* où *bones* représente nos 10 mesures (et donc nos 10 variables numériques). Le centrage - réduction permet d'avoir une moyenne centrée sur 0 et un variance réduire à 1, il suffit d'appliquer la formule suivante : $X = \frac{X - \mu}{\sigma}$. Ainsi il est possible d'observer le résultat du centrage-réduction sur le boxplot du milieu. On remarquera que l'unité en abscisse n'est plus la même et que sont échelle à changé.  

Par ailleurs nous observons qu'il existe des points aberrants, appelés aussi *outliers*. Pour les éliminer, nous avons créé une fonction *filter_outliers* (disponible dans le code R) qui stocke dans un index les lignes  comportant des outliers définis selon un seuil arbitraire (dans notre cas : 3). La fonction applique ensuite une suppression des lignes indexées sur le jeu de données voulu et renvoie le jeu et l'indexe avec les lignes comportant des outliers. Le résultat de cette opération est visible dans le 3ème boxplot le plus à droite. 


```{r centrage réduction }
par(mfrow = c(1, 3), mar = c(5, 5, 4, 2) + 0.1 )


boxplot(birds[2:11], horizontal = T, las = 1, 
        main = "Avant centrage et reduction",
        cex.main = 0.75,
        col = "lightblue")


boxplot(scale(birds[2:11]), horizontal = T, las = 1,
        main = "Apres centrage et reduction",
        cex.main = 0.75,
        col = "lightblue")

index <- filter_outliers(scale(birds[2:10]), limit = 3)

boxplot(scale(birds[2:10])[-c(index),], horizontal = T, las = 1,
        main = "Apres suppression des outliers",
        cex.main = 0.75,
        col = "lightblue")

```


# Analyses Multivariées :

## 1. Analyse en composante principales  (ACP) :

Lorsque l'on fait le *summary* de l'ACP, on peut d'abord jeter un œil sur les valeurs propres obtenues. Celui-ci nous dit qu'il y a 10 valeurs propres en tout, seul 5 d'entre elles sont montrées.

Les valeurs propres nous renseignent sur la fraction de l’inertie totale prise en compte par chaque axe. Elles sont rangées par convention dans l’ordre décroissant. Le premier axe représente 87 % de l'inertie totale et le deuxième axe représente 6.5% de l'inertie. Si l'on ne conserve que ces deux valeurs propres là, leur somme (ou cumul) étant égale à 93% est suffisant pour représenter l'inertie totale, il est possible de représenter la projection de nos 10 variables dans un repère définit par nos 2 axes principaux grâce à la commande *s.corcircle*. 

Sur le premier facteur nos 10 variables pointent toutes du même coté. Cela est dû à "l'effet taille" lorsque les variables sont toutes corrélées positivement entres elles. Lorsque nous avons un angle aigu entre deux flèches, cela signifie que nos 2 variables en questions sont très corrélées. C'est par exemple le cas entre la longueur de l'Ulna et son diamètre, ou entre la longueur de l'humérus et son diamètre, ce qui est plutôt cohérent d'un point de vue anatomique. Plus l'angle entre deux variables est faible et plus les variables sont corrélées, avec un coefficient de corrélation $r^{2} \approx 1$

Pour le deuxième facteur, on voit que nous avons autant de variables de part et d'autre de l'axe horizontal, cinq au dessus et cinq dessous. En dessous nous avons les variables relatives à l'os ulna et à l'humérus ce qui correspondrait plutôt au membre supérieur des oiseaux tandis qu'au dessus de l'axe horizontal nous voyons les variables concernant les mesures sur les os du fémur et du tibiotarse et du tarso-métatarse (pied), soit au membre inférieur de l'oiseau. 

```{r birds2}
birds2 <- birds[, 2:12]
birds2[, 1:10] <- scale(birds2[, 1:10])
colnames(birds2)[11] <- 'groups'
birds2 <- birds2[-c(index),]
```

```{r ACP}
pca.birds <- dudi.pca(df = birds2[1:10] , scannf = FALSE, nf = 2)
summary(pca.birds)
par(mfrow = c(1, 2))
s.corcircle(pca.birds$c1, xax =1, yax = 2)
#scatter(pca.birds)
```
## 2. Between-Class Analysis (BCA) and Linear Discriminant Analysis (LDA) :

```{r BCA}
bca <- bca(pca.birds, as.factor(birds2$groups), scannf = FALSE, nf = 2)
summary(bca)
bca$tab
plot(bca)
```

```{r LDA}
lda <- discrimin(pca.birds, as.factor(birds2$groups), scannf = FALSE, nf = 2)
summary(lda)
plot(lda)
```


## 3. Regroupement des valeurs par groupes écologiques :

Pour la suite de ce devoir nous voudrions regrouper les individus par groupes écologiques afin de voir si des groupes peuvent êtres caractérisés par certaines variables. Dans notre jeu de données actuel, la dernière variable *birds$type* indique de le groupe écologique auquel l'individu appartient. Une idée serait de regrouper tous les individus d'un même groupe en effectuant par exemple la moyenne de leur valeurs pour chaque attribut respectif. On obtiendrait donc un tableau de taille $6 * 11$ (*nombre de groupes * * *nombre de variables*). Dans le cas où l'on ferait une moyenne, on peut considérer que celles-ci soit assez représentatives car nous avons un grand nombre d'individus par groupe et que les valeurs aberrantes (outliers) ont été supprimées précédemment et n'affecteront donc pas les moyennes calculées. Pour obtenir cette table on peut utiliser la fonction *aggregate()*. 

Remarque : Il serait également possible de faire une table basée sur les médianes plutôt les moyennes. 

```{r tab of mean per ecologic group}
meantab <-  aggregate(birds2[,1:10], list(birds2$groups), mean)
colnames(meantab)[1] <- 'groups'
meantab$groups <- as.numeric(as.factor(meantab$groups))
```

Afin de pouvoir utiliser la variable *ecogroups* dans nos prochains tests multivariés, il faut d'abord la transformer en facteur numérique avec les fonctions *as.numeric( as.factor() )*. Par défaut la conversion se fait par ordre alpha-numérique, ainsi les groupes écologiques deviennent respectivement : **{ P: 1, R: 2, SO: 3, SW: 4, T: 5, W: 6} **^ 

```{r dendrogram }
dbirds <- round(dist(meantab), 3)
pco.birds <- dudi.pco(dbirds, scannf = FALSE)
summary(pco.birds)
#scatter(pco.birds)

clusty <- hclust(dbirds, "complete")
par(mfrow = c(1, 2))

plot(clusty, main = "Dendrogram of ecologic classes of birds", cex.main = 0.85, cex = 0.75, xlab = "")

plot(rev(clusty$height), type = 'l', 
     main = "Decreasing heights of the dendogram",
     ylab = "height", xlab = "", las = 1,
     cex.main = 0.85)
```




